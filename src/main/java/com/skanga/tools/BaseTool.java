package com.skanga.tools;

import com.skanga.tools.exceptions.MissingToolParameterException;
import com.skanga.tools.exceptions.ToolCallableException;
import com.skanga.tools.exceptions.ToolException;
import com.skanga.tools.properties.PropertyType;
import com.skanga.tools.properties.ToolProperty;
import com.skanga.tools.properties.BaseToolProperty; // For the anonymous inner class in addParameter

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap; // To maintain parameter order in schema
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * A base implementation of the {@link Tool} interface.
 * It provides storage for tool definition (name, description, parameters)
 * and execution state (callable, inputs, call ID, result).
 *
 * <p>This class handles:
 * <ul>
 *   <li>Storing and retrieving tool metadata.</li>
 *   <li>Managing a list of {@link ToolProperty} objects for parameters.</li>
 *   <li>Generating a JSON schema for the tool's parameters, suitable for use with
 *       AI models that support function calling or tool usage.</li>
 *   <li>Executing a {@link ToolCallable} and managing its inputs and results.</li>
 *   <li>Validating that required parameters are provided before execution.</li>
 * </ul>
 * </p>
 *
 * <p>The JSON schema generated by {@link #getJsonSchema()} describes the structure
 * of the parameters this tool accepts. For AI providers like OpenAI, this schema
 * is typically nested within a "function" definition that includes the tool's
 * name and description.</p>
 */
public class BaseTool implements Tool {
    /** The name of the tool, used for identification by AI models. */
    protected final String name;
    /** A human-readable description of the tool's purpose and functionality. */
    protected final String description;
    /** List of parameters (defined as {@link ToolProperty}) that this tool accepts. */
    protected List<ToolProperty> parameters = new ArrayList<>();
    /** The actual executable logic of the tool. */
    protected ToolCallable callable;
    /** Input arguments for a specific invocation of this tool. */
    private Map<String, Object> inputs = Collections.emptyMap();
    /** Call ID associated with a specific invocation, often from the AI model. */
    protected String callId;
    /** Result of the last execution of the tool's callable. */
    protected Object result;

    /**
     * Constructs a new BaseTool with a given name and description.
     *
     * @param name        The name of the tool. Must not be null.
     * @param description A description of what the tool does. Must not be null.
     */
    public BaseTool(String name, String description) {
        Objects.requireNonNull(name, "Tool name cannot be null.");
        if (name.trim().isEmpty()) {
            throw new IllegalArgumentException("Tool name cannot be empty.");
        }
        Objects.requireNonNull(description, "Tool description cannot be null.");
        this.name = name;
        this.description = description;
    }

    /**
     * Adds a parameter definition to this tool.
     *
     * @param parameter The {@link ToolProperty} defining the parameter. Must not be null.
     * @return This {@code BaseTool} instance for fluent chaining.
     */
    public BaseTool addParameter(ToolProperty parameter) {
        Objects.requireNonNull(parameter, "ToolProperty to add cannot be null.");
        this.parameters.add(parameter);
        return this;
    }

    /**
     * Convenience method to add a simple scalar parameter to this tool.
     * This creates a basic {@link BaseToolProperty} internally. For complex types like
     * "object" or "array", use {@link #addParameter(ToolProperty)} with an instance of
     * {@link com.skanga.tools.properties.ObjectToolProperty} or
     * {@link com.skanga.tools.properties.ArrayToolProperty}.
     *
     * @param name        The name of the parameter.
     * @param type        The {@link PropertyType} of the parameter (e.g., STRING, INTEGER).
     * @param description A description of the parameter.
     * @param required    True if this parameter is required, false otherwise.
     * @return This {@code BaseTool} instance for fluent chaining.
     */
    public BaseTool addParameter(String name, PropertyType type, String description, boolean required) {
        // Using an anonymous inner class for BaseToolProperty as it's abstract and this is for simple types.
        // This is a direct way to add common scalar properties without creating explicit property classes for each.
        this.parameters.add(new BaseToolProperty(name, type, description, required) {
            // No additional overrides needed beyond what BaseToolProperty provides for simple types.
        });
        return this;
    }


    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public List<ToolProperty> getParameters() {
        return Collections.unmodifiableList(parameters);
    }

    @Override
    public List<String> getRequiredParameters() {
        return parameters.stream()
                .filter(ToolProperty::isRequired)
                .map(ToolProperty::getName)
                .collect(Collectors.toList());
    }

    @Override
    public void setCallable(ToolCallable callable) {
        this.callable = callable;
    }

    /**
     * Gets the {@link ToolCallable} associated with this tool.
     * @return The callable, or null if not set.
     */
    public ToolCallable getCallable() {
        return callable;
    }

    @Override
    public Map<String, Object> getInputs() {
        return inputs;
    }

    @Override
    public Tool setInputs(Map<String, Object> inputs) {
        this.inputs = inputs != null ?
                Collections.unmodifiableMap(new LinkedHashMap<>(inputs)) :
                Collections.emptyMap();
        return this;
    }
    @Override
    public String getCallId() {
        return callId;
    }

    @Override
    public Tool setCallId(String callId) {
        this.callId = callId;
        return this;
    }

    @Override
    public Object getResult() {
        return result;
    }

    @Override
    public void executeCallable() throws MissingToolParameterException, ToolCallableException {
        if (this.callable == null) {
            throw new ToolCallableException("No callable has been set for tool: " + getName());
        }

        // Validate required inputs
        for (ToolProperty param : parameters) {
            if (param.isRequired() && !this.inputs.containsKey(param.getName())) {
                throw new MissingToolParameterException(getName(), param.getName());
            }
            // TODO: Advanced input validation and type conversion based on param.getPropertyType()
            // could be added here before passing to the callable.
            // For example, ensuring an INTEGER property is actually a number.
            // The current ToolExecutionInput takes Map<String, Object>, so callable receives raw args.
        }

        ToolExecutionInput executionInput = new ToolExecutionInput(this.inputs); // Defensive copy made by record
        try {
            ToolExecutionResult executionResult = this.callable.execute(executionInput);
            this.result = executionResult.result(); // Store the actual result object
        } catch (Exception e) {
            this.result = null; // Clear previous result on error to avoid stale data
            throw new ToolCallableException("Error executing tool '" + getName() + "': " + e.getMessage(), e);
        }
    }

    /**
     * {@inheritDoc}
     * <p>
     * For a {@link BaseTool}, this generates the JSON schema for its parameters.
     * This schema is typically an object where keys are parameter names and values
     * are their respective JSON schemas (obtained from each {@link ToolProperty#getJsonSchema()}).
     * It also includes a "required" array listing the names of mandatory parameters.
     * </p>
     * <p>
     * This schema is what AI models like OpenAI use for the "parameters" field of a
     * function/tool definition.
     * </p>
     * Example for a tool with parameters "location" (string, required) and "unit" (string, enum):
     * <pre>{@code
     * {
     *   "type": "object",
     *   "properties": {
     *     "location": {"type": "string", "description": "City, e.g., San Francisco, CA"},
     *     "unit": {"type": "string", "enum": ["celsius", "fahrenheit"], "description": "Temperature unit"}
     *   },
     *   "required": ["location"]
     * }
     * }</pre>
     */
    @Override
    public Map<String, Object> getJsonSchema() {
        Map<String, Object> schema = new LinkedHashMap<>();
        schema.put("type", "object"); // The parameters of a function are collectively an object.

        Map<String, Object> paramsSchema = new LinkedHashMap<>();
        for (ToolProperty param : parameters) {
            paramsSchema.put(param.getName(), param.getJsonSchema());
        }

        if (!paramsSchema.isEmpty()) {
            schema.put("properties", paramsSchema);
        }

        List<String> requiredParams = getRequiredParameters();
        if (!requiredParams.isEmpty()) {
            schema.put("required", requiredParams);
        }

        return schema;
    }

    /**
     * {@inheritDoc}
     * <p>
     * For a {@link BaseTool}, this serializes the tool's main definition, including its name,
     * description, and the JSON schema of its parameters (obtained from {@link #getJsonSchema()}).
     * This map is suitable for representing the entire tool definition for external use or display,
     * often conforming to how AI providers expect a "function" or "tool" to be described.
     * </p>
     * Example for OpenAI:
     * <pre>{@code
     * {
     *   "type": "function", // Added by provider typically
     *   "function": {
     *      "name": "my_tool_name",
     *      "description": "My tool description",
     *      "parameters": { // This is the map from getJsonSchema()
     *          "type": "object",
     *          "properties": { ... },
     *          "required": [ ... ]
     *      }
     *   }
     * }
     * }</pre>
     * This method provides the inner "function" like part if name/description were top-level.
     * Or, it can represent the tool fully if the context implies it.
     * For now, it focuses on name, desc, and parameters schema.
     */
    @Override
    public Map<String, Object> toJsonSerializableMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("name", getName());
        map.put("description", getDescription());
        map.put("parameters_schema", getJsonSchema()); // The schema for the tool's parameters object
        return map;
    }
}
